;---------------------------------
; 多勢力指定近傍船検索関数(キャッシュ対応版)
; 指定地点から最も近いセクターに居る中で最も短い距離で自動移動できる位置に存在する指定された勢力の船を探す
; 複数回使うのならキャッシュを利用する事でいくらか軽くなるかもしれない
;---------------------------------
;指定された勢力の船が見つからなければ"-1"、そうでないなら最も近い船のIDを返す。
;ここで言う「最も近い船」とは「最もセクターが近い距離」にある船の中でも「自動航行で最も短い距離で移動できる位置」にある船で、その中でも最も小さいID番号を持つ船の事になる。
;CLOSERANGE 下限距離。この距離よりも小さい距離の場合には更新しない。
;船の購入条件とは違って「国家ID == 0」の初期化状態の船が出て来るのでヘッダー調整は無し
@SHIP_SECTOR_CACHED_NEAREST_SHIP_CHECK(CENTER_POS, CHECK_COUNTRY, CLOSERANGE = 0)
#DIM CENTER_POS
#DIM CHECK_COUNTRY
#DIM CLOSERANGE

#DIM CHECK_SHIP_ID
#DIM CHECK_SECTOR_DISTANCE
#DIM CHECK_POS_DISTANCE

#DIM NEAREST_SHIP_ID
#DIM NEAREST_SECTOR_DISTANCE
#DIM NEAREST_POS_DISTANCE

#DIM CENTER_SECTOR
#DIM CHECK_SECTOR_X
#DIM CHECK_SECTOR_Y
#DIM CHECK_SECTOR_ID

;SECTOR_DISTANCE_ARRAY:セクター間の距離:(0=総数 1以降=その距離にあるセクター)
#DIM SECTOR_DISTANCE_ARRAY, (MAX_SECTOR_X + MAX_SECTOR_Y - 2) + 1, (MAX_SECTOR_X + MAX_SECTOR_Y - 2) + 1

#DIM CONST 該当セクター数 = 0
#DIM CONST セクター内船数 = 0

;初期化
NEAREST_SHIP_ID = -1
NEAREST_SECTOR_DISTANCE = 999
NEAREST_POS_DISTANCE = -1

;PRINTFORML 下限距離{CLOSERANGE}で検索します

CALL SHIP_SECTOR_CACHE_CHECK
SELECTCASE RESULT

CASE 0
	;未キャッシュならキャッシュ機能付きの既存処理へ
	FOR CHECK_SHIP_ID, 0, MAX_SHIP
		;国家IDが0=中身のない船だったら次周へ
		SIF SHIP_COUNTRY:CHECK_SHIP_ID == 0
			CONTINUE
		;扱いきれない範囲の国家IDだったらとりあえず次周へ
		SIF SHIP_COUNTRY:CHECK_SHIP_ID < 0 || SHIP_COUNTRY:CHECK_SHIP_ID > 63
			CONTINUE
		CALL SHIP_SECTOR_CACHED_POS_DISTANCE_CHECK(CENTER_POS, CHECK_SHIP_ID)
		CHECK_SECTOR_DISTANCE = RESULT:0
		CHECK_POS_DISTANCE = RESULT:1
		IF GETBIT(CHECK_COUNTRY, (SHIP_COUNTRY:CHECK_SHIP_ID))
			; 距離が下限距離以上であるのなら、セクター間の距離が今までで一番小さいか、セクター間の距離が同じで最も短い距離が0よりも小さい=初期化されたままの場合か、チェック中の船の距離が今までで一番短い距離の船であるなら、最も短い距離の船を更新する。
			IF CLOSERANGE <= CHECK_POS_DISTANCE && (NEAREST_SECTOR_DISTANCE > CHECK_SECTOR_DISTANCE || (NEAREST_SECTOR_DISTANCE == CHECK_SECTOR_DISTANCE && (NEAREST_POS_DISTANCE < 0 || NEAREST_POS_DISTANCE > CHECK_POS_DISTANCE)))
				NEAREST_SHIP_ID = CHECK_SHIP_ID
				NEAREST_SECTOR_DISTANCE = CHECK_SECTOR_DISTANCE
				NEAREST_POS_DISTANCE = CHECK_POS_DISTANCE
				;PRINTFORML 距離{NEAREST_POS_DISTANCE}のID{NEAREST_SHIP_ID} %SHIP_NAME:NEAREST_SHIP_ID%で更新しました
			ENDIF
		ENDIF
	NEXT
CASE 1
	VARSET SECTOR_DISTANCE_ARRAY
	;キャッシュ済みならキャッシュで絞り込んでから比較する
	CALL ID2POS(CENTER_POS)
	CENTER_SECTOR = RESULT:0

	;セクター間距離毎に船のあるセクターを格納する
	FOR CHECK_SECTOR_ID, 0, MAX_SECTOR
		SIF SHIP_SECTOR_CACHE:CHECK_SECTOR_ID:セクター内船数 == 0
			CONTINUE
		CALL SECTOR_DISTANCE_CHECK(CENTER_SECTOR, CHECK_SECTOR_ID)
		CHECK_SECTOR_DISTANCE = RESULT
		SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:該当セクター数 ++
		SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:(SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:該当セクター数) = CHECK_SECTOR_ID
	NEXT
	;セクター間距離毎に該当セクター内の船との距離確認
	FOR CHECK_SECTOR_DISTANCE, 0, (MAX_SECTOR_X + MAX_SECTOR_Y - 2) + 1
		FOR CHECK_SECTOR_ID, 1, (SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:該当セクター数) + 1
			FOR CHECK_SHIP_ID, 1, (SHIP_SECTOR_CACHE:(SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:CHECK_SECTOR_ID):セクター内船数) + 1
				;国家IDが0=中身のない船だったら次周へ
				SIF SHIP_COUNTRY:(SHIP_SECTOR_CACHE:(SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:CHECK_SECTOR_ID):CHECK_SHIP_ID) == 0
					CONTINUE
				;扱いきれない範囲の国家IDだったらとりあえず次周へ
				SIF SHIP_COUNTRY:(SHIP_SECTOR_CACHE:(SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:CHECK_SECTOR_ID):CHECK_SHIP_ID) < 0 || SHIP_COUNTRY:(SHIP_SECTOR_CACHE:(SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:CHECK_SECTOR_ID):CHECK_SHIP_ID) > 63
					CONTINUE
				IF GETBIT(CHECK_COUNTRY, SHIP_COUNTRY:(SHIP_SECTOR_CACHE:(SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:CHECK_SECTOR_ID):CHECK_SHIP_ID))
					CALL POS_DISTANCE_CHECK(CENTER_POS, SHIP_POSITION:(SHIP_SECTOR_CACHE:(SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:CHECK_SECTOR_ID):CHECK_SHIP_ID))
					;CHECK_SECTOR_DISTANCE = RESULT:0
					CHECK_POS_DISTANCE = RESULT:1
					;PRINTFORML セクター{SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:CHECK_SECTOR_ID}・距離{CHECK_POS_DISTANCE}のID{SHIP_SECTOR_CACHE:(SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:CHECK_SECTOR_ID):CHECK_SHIP_ID} %SHIP_NAME:(SHIP_SECTOR_CACHE:(SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:CHECK_SECTOR_ID):CHECK_SHIP_ID)%を確認します
					; 距離が下限距離以上であるのなら、最も短い距離が0よりも小さい=初期化されたままの場合か、チェック中の船の距離が今までで一番短い距離の船であるなら、最も短い距離の船を更新する。
					IF CLOSERANGE <= CHECK_POS_DISTANCE && (NEAREST_POS_DISTANCE < 0 || NEAREST_POS_DISTANCE > CHECK_POS_DISTANCE)
						NEAREST_SHIP_ID = SHIP_SECTOR_CACHE:(SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:CHECK_SECTOR_ID):CHECK_SHIP_ID
						NEAREST_SECTOR_DISTANCE = CHECK_SECTOR_DISTANCE
						NEAREST_POS_DISTANCE = CHECK_POS_DISTANCE
						;PRINTFORML セクター{SECTOR_DISTANCE_ARRAY:CHECK_SECTOR_DISTANCE:CHECK_SECTOR_ID}・距離{NEAREST_POS_DISTANCE}のID{NEAREST_SHIP_ID} %SHIP_NAME:NEAREST_SHIP_ID%で更新しました
					ENDIF
				ENDIF
			;セクター内の船を確認
			NEXT
		;セクター内の船を全て確認
		NEXT
	;当該距離の船全部確認
	;有効なIDが入っていたら終わり
	SIF NEAREST_SHIP_ID >= 0
		BREAK
	NEXT
ENDSELECT
RETURN NEAREST_SHIP_ID

;---------------------------------
; 指定された2つの座標のセクター同士の距離・距離(単位・マス目)を返す(キャッシュ保存機能付き)
; RESULT:0 MOVERとTARGETの居るセクターの距離
; RESULT:1 (TARGETが静止しているものとして)MOVERが自動航行でTARGETまで移動する場合の距離
; (セクター間移動の場合は1セクター=13マス(セクターに進入した時点で1マス内側に出るので)で移動として計算(セクターが長方形とかになるとこの方法は使えなくなる)+始点・終点の移動は自動移動でのセクターからの脱出・セクターへの進入の動きを考えたもので計算)
;---------------------------------
; 「移動」命令などで(自動航行で)対象の船を追いかけるのを前提に追いかける(MOVER)側と追いかけられる(TARGET)側とする
; これが返す距離はあくまで自動航行の動きで移動した場合の距離なのでMOVERとTARGETがひっくり返ると別の答えが出る。
@SHIP_SECTOR_CACHED_POS_DISTANCE_CHECK(MOVER_POS, TARGET_SHIP_ID)
#DIM MOVER_POS
#DIM MOVER_SECTOR_ID
#DIM MOVER_SECTOR_POS_Y
#DIM MOVER_SECTOR_POS_X
#DIM MOVER_X_POS
#DIM MOVER_Y_POS

#DIM TARGET_SHIP_ID
#DIM TARGET_SECTOR_ID
#DIM TARGET_SECTOR_POS_Y
#DIM TARGET_SECTOR_POS_X
#DIM TARGET_X_POS
#DIM TARGET_Y_POS

#DIM SECTOR_Y_DISTANCE
#DIM SECTOR_X_DISTANCE

#DIM X_POS_DISTANCE
#DIM Y_POS_DISTANCE

#DIM POS_DISTANCE
#DIM SECTOR_DISTANCE

#DIM CONST ONESECTOR_MOVING_DISTANCE = 13

CALL ID2POS(MOVER_POS)
MOVER_SECTOR_ID = RESULT:0
MOVER_X_POS = RESULT:1
MOVER_Y_POS = RESULT:2

; セクターは横方向が下の桁・縦方向が上の桁っぽい
; 移動処理側ではセクターの縦方向をY軸と呼んでいる
MOVER_SECTOR_POS_Y = MOVER_SECTOR_ID / 10
MOVER_SECTOR_POS_X = MOVER_SECTOR_ID - (MOVER_SECTOR_POS_Y * 10)

CALL ID2POS(SHIP_POSITION:TARGET_SHIP_ID)
TARGET_SECTOR_ID = RESULT:0
TARGET_X_POS = RESULT:1
TARGET_Y_POS = RESULT:2

;SSCにキャッシュする
SHIP_SECTOR_CACHE:TARGET_SECTOR_ID:0 ++
SHIP_SECTOR_CACHE:TARGET_SECTOR_ID:(SHIP_SECTOR_CACHE:TARGET_SECTOR_ID:0) = TARGET_SHIP_ID
;PRINTFORML SHIP_SECTOR_CACHE:{TARGET_SECTOR_ID}の{SHIP_SECTOR_CACHE:TARGET_SECTOR_ID:0}番目に%SHIP_NAME:(SHIP_SECTOR_CACHE:TARGET_SECTOR_ID:(SHIP_SECTOR_CACHE:TARGET_SECTOR_ID:0))%


TARGET_SECTOR_POS_Y = TARGET_SECTOR_ID / 10
TARGET_SECTOR_POS_X = TARGET_SECTOR_ID - TARGET_SECTOR_POS_Y * 10

SECTOR_Y_DISTANCE = MOVER_SECTOR_POS_Y - TARGET_SECTOR_POS_Y
SECTOR_X_DISTANCE = MOVER_SECTOR_POS_X - TARGET_SECTOR_POS_X

IF SECTOR_Y_DISTANCE != 0
	; 上下に差があるなら
	X_POS_DISTANCE = ABS(MOVER_X_POS - MAP_WIDTH / 2)
	IF SECTOR_Y_DISTANCE > 0
		; 少なくとも上
		Y_POS_DISTANCE = MOVER_Y_POS
		IF SECTOR_X_DISTANCE > 0
			; 左上
			X_POS_DISTANCE += ABS((MAP_WIDTH - 2) - TARGET_X_POS)
			Y_POS_DISTANCE += ABS(TARGET_Y_POS - MAP_HEIGHT / 2)
		ELSEIF SECTOR_X_DISTANCE < 0
			; 右上
			X_POS_DISTANCE += ABS(1 - TARGET_X_POS)
			Y_POS_DISTANCE += ABS(TARGET_Y_POS - MAP_HEIGHT / 2)
		ELSE
			; 純粋に上
			X_POS_DISTANCE += ABS(TARGET_X_POS - MAP_WIDTH / 2)
			Y_POS_DISTANCE += ABS(MAP_HEIGHT - TARGET_Y_POS - 2)
		ENDIF
	ELSE
		; 少なくとも下
		Y_POS_DISTANCE = MAP_HEIGHT - (MOVER_Y_POS + 1)
		IF SECTOR_X_DISTANCE > 0
			; 左下
			X_POS_DISTANCE += ABS(MAP_WIDTH - TARGET_X_POS - 2)
			Y_POS_DISTANCE += ABS(TARGET_Y_POS - MAP_HEIGHT / 2)
		ELSEIF SECTOR_X_DISTANCE < 0
			; 右下
			X_POS_DISTANCE += ABS(1 - TARGET_X_POS)
			Y_POS_DISTANCE += ABS(TARGET_Y_POS - MAP_HEIGHT / 2)
		ELSE
			; 純粋に下
			X_POS_DISTANCE += ABS(TARGET_X_POS - MAP_WIDTH / 2)
			Y_POS_DISTANCE += ABS(1 - TARGET_Y_POS)
		ENDIF
	ENDIF
ELSEIF SECTOR_X_DISTANCE != 0
	; 上下には差がなくて・左右に差があるなら
	Y_POS_DISTANCE = ABS(MOVER_Y_POS - MAP_HEIGHT / 2)
	Y_POS_DISTANCE += ABS(TARGET_Y_POS - MAP_HEIGHT / 2)
	IF SECTOR_X_DISTANCE > 0
		; 左
		X_POS_DISTANCE = MOVER_X_POS
		X_POS_DISTANCE += ABS(MAP_WIDTH - TARGET_X_POS - 2)
	ELSE
		; 右
		X_POS_DISTANCE = MAP_WIDTH - (MOVER_X_POS + 1)
		X_POS_DISTANCE += ABS(1 - TARGET_X_POS)
	ENDIF
ELSE
	; 同一セクターなら
	X_POS_DISTANCE = ABS(MOVER_X_POS - TARGET_X_POS)
	Y_POS_DISTANCE = ABS(MOVER_Y_POS - TARGET_Y_POS)
ENDIF

SECTOR_DISTANCE = ABS(SECTOR_Y_DISTANCE) + ABS(SECTOR_X_DISTANCE)
IF SECTOR_DISTANCE == 0
	POS_DISTANCE = X_POS_DISTANCE + Y_POS_DISTANCE
ELSE
	POS_DISTANCE = (SECTOR_DISTANCE - 1) * ONESECTOR_MOVING_DISTANCE + X_POS_DISTANCE + Y_POS_DISTANCE
ENDIF

RESULT:0 = SECTOR_DISTANCE
RESULT:1 = POS_DISTANCE

RETURN RESULT

;セクター距離判定特化関数
@SECTOR_DISTANCE_CHECK(SECTOR_1, SECTOR_2)
#DIM SECTOR_1
#DIM SECTOR_2

#DIM SECTOR_1_POS_Y
#DIM SECTOR_1_POS_X

#DIM SECTOR_2_POS_Y
#DIM SECTOR_2_POS_X

SECTOR_1_POS_Y = SECTOR_1 / 10
SECTOR_1_POS_X = SECTOR_1 - SECTOR_1_POS_Y * 10

SECTOR_2_POS_Y = SECTOR_2 / 10
SECTOR_2_POS_X = SECTOR_2 - SECTOR_2_POS_Y * 10

RETURN ABS(SECTOR_1_POS_Y - SECTOR_2_POS_Y) + ABS(SECTOR_1_POS_X - SECTOR_2_POS_X)

;---------------------------------
;キャッシュがあるかを確認
;---------------------------------
@SHIP_SECTOR_CACHE_CHECK
#DIM CHECK_SECTOR
FOR CHECK_SECTOR, 0, MAX_SECTOR
	SIF SHIP_SECTOR_CACHE:CHECK_SECTOR:0 > 0
		RETURN 1
NEXT
RETURN 0


;---------------------------------
; 多勢力指定遠方船検索関数
; 指定地点から最も短い距離で自動移動できる位置に存在する指定された勢力の船を探す
; NEAREST_MULTIPLE_ANY_COUNTRY_SHIP_CHECKのバリエーション関数で不等号の向きを変えて遠方の船を探す様にした
;---------------------------------
;指定された勢力の船が見つからなければ"-1"、そうでないなら最も遠い船のIDを返す。
;ここで言う「最も遠い船」とは「自動航行で最も遠い距離で移動できる位置」にあり、最も遠い同一の距離で移動できる位置の船の中では「最もセクターが遠い距離」にある船、その中でも最も小さいID番号を持つ船の事になる。
;OUTRANGE 上限距離。この距離よりも大きい距離の場合には更新しない。
;船の購入条件とは違って「国家ID == 0」の初期化状態の船が出て来るのでヘッダー調整は無し
@FURTHEST_MULTIPLE_ANY_COUNTRY_SHIP_CHECK(CENTER_POS, CHECK_COUNTRY, OUTRANGE = 999)
#DIM CENTER_POS
#DIM CHECK_COUNTRY
#DIM OUTRANGE

#DIM CHECK_SHIP_ID
#DIM CHECK_SECTOR_DISTANCE
#DIM CHECK_POS_DISTANCE

#DIM FURTHEST_SHIP_ID
#DIM FURTHEST_SECTOR_DISTANCE
#DIM FURTHEST_POS_DISTANCE


;初期化
FURTHEST_SHIP_ID = -1
FURTHEST_SECTOR_DISTANCE = -1
FURTHEST_POS_DISTANCE = -1

;PRINTFORML 上限距離{OUTRANGE}で検索します

FOR CHECK_SHIP_ID, 0, MAX_SHIP
	;扱いきれない範囲の国家IDだったらとりあえず次周へ
	SIF SHIP_COUNTRY:CHECK_SHIP_ID < 0 || SHIP_COUNTRY:CHECK_SHIP_ID > 63
		CONTINUE
	IF GETBIT(CHECK_COUNTRY, (SHIP_COUNTRY:CHECK_SHIP_ID))
		CALL POS_DISTANCE_CHECK(CENTER_POS, SHIP_POSITION:CHECK_SHIP_ID)
		CHECK_SECTOR_DISTANCE = RESULT:0
		CHECK_POS_DISTANCE = RESULT:1

		; 距離が上限距離以下であるのなら、チェック中の船の距離が今までで一番遠い距離の船であるか、距離は同じでもセクターがより遠い船であるなら、最も遠い距離の船を更新する。
		IF OUTRANGE >= CHECK_POS_DISTANCE && (FURTHEST_POS_DISTANCE < CHECK_POS_DISTANCE || (FURTHEST_POS_DISTANCE == CHECK_POS_DISTANCE && FURTHEST_SECTOR_DISTANCE < CHECK_SECTOR_DISTANCE ))
			FURTHEST_SHIP_ID = CHECK_SHIP_ID
			FURTHEST_SECTOR_DISTANCE = CHECK_SECTOR_DISTANCE
			FURTHEST_POS_DISTANCE = CHECK_POS_DISTANCE
			;PRINTFORML 距離{FURTHEST_POS_DISTANCE}のID{FURTHEST_SHIP_ID} %SHIP_NAME:FURTHEST_SHIP_ID%で更新しました
		ENDIF
	ENDIF
NEXT
RETURN FURTHEST_SHIP_ID

;---------------------------------
; 多勢力指定近傍船検索関数(近すぎ判定追加版)
; 指定地点から最も短い距離で自動移動できる位置に存在する指定された勢力の船を探す
; CHECK_COUNTRYに勢力情報をビット演算方式で入れる事で複数の勢力を指定しつつ、近すぎる船を弾く事で「適度に距離がある船」を探せる様にした↓の改良版
;---------------------------------
;指定された勢力の船が見つからなければ"-1"、そうでないなら最も近い船のIDを返す。
;ここで言う「最も近い船」とは「自動航行で最も短い距離で移動できる位置」にあり、最も近い同一の距離で移動できる位置の船の中では「最もセクターが近い距離」にある船、その中でも最も小さいID番号を持つ船の事になる。
;CLOSERANGE 下限距離。この距離よりも小さい距離の場合には更新しない。
;船の購入条件とは違って「国家ID == 0」の初期化状態の船が出て来るのでヘッダー調整は無し
@NEAREST_MULTIPLE_ANY_COUNTRY_SHIP_CHECK(CENTER_POS, CHECK_COUNTRY, CLOSERANGE = 0)
#DIM CENTER_POS
#DIM CHECK_COUNTRY
#DIM CLOSERANGE

#DIM CHECK_SHIP_ID
#DIM CHECK_SECTOR_DISTANCE
#DIM CHECK_POS_DISTANCE

#DIM NEAREST_SHIP_ID
#DIM NEAREST_SECTOR_DISTANCE
#DIM NEAREST_POS_DISTANCE


;初期化
NEAREST_SHIP_ID = -1
NEAREST_SECTOR_DISTANCE = -1
NEAREST_POS_DISTANCE = -1

;PRINTFORML 下限距離{CLOSERANGE}で検索します

FOR CHECK_SHIP_ID, 0, MAX_SHIP
	;扱いきれない範囲の国家IDだったらとりあえず次周へ
	SIF SHIP_COUNTRY:CHECK_SHIP_ID < 0 || SHIP_COUNTRY:CHECK_SHIP_ID > 63
		CONTINUE
	IF GETBIT(CHECK_COUNTRY, (SHIP_COUNTRY:CHECK_SHIP_ID))
		CALL POS_DISTANCE_CHECK(CENTER_POS, SHIP_POSITION:CHECK_SHIP_ID)
		CHECK_SECTOR_DISTANCE = RESULT:0
		CHECK_POS_DISTANCE = RESULT:1

		; 距離が下限距離以上であるのなら、最も短い距離が0よりも小さい=初期化されたままの場合か、チェック中の船の距離が今までで一番短い距離の船であるか、距離は同じでもセクターがより近い船であるなら、最も短い距離の船を更新する。
		IF CLOSERANGE <= CHECK_POS_DISTANCE && (NEAREST_POS_DISTANCE < 0 || NEAREST_POS_DISTANCE > CHECK_POS_DISTANCE || (NEAREST_POS_DISTANCE == CHECK_POS_DISTANCE && NEAREST_SECTOR_DISTANCE > CHECK_SECTOR_DISTANCE ))
			NEAREST_SHIP_ID = CHECK_SHIP_ID
			NEAREST_SECTOR_DISTANCE = CHECK_SECTOR_DISTANCE
			NEAREST_POS_DISTANCE = CHECK_POS_DISTANCE
			;PRINTFORML 距離{NEAREST_POS_DISTANCE}のID{NEAREST_SHIP_ID} %SHIP_NAME:NEAREST_SHIP_ID%で更新しました
		ENDIF
	ENDIF
NEXT
RETURN NEAREST_SHIP_ID

;---------------------------------
; 勢力指定近傍船検索関数
; 指定地点から最も短い距離で自動移動できる位置に存在する指定された勢力の船を探す
;---------------------------------
;一切その勢力の船が見つからなければ"-1"、そうでないなら最も近い船のIDを返す。
;ここで言う「最も近い船」とは「自動航行で最も短い距離で移動できる位置」にあり、最も近い同一の距離で移動できる位置の船の中では「最もセクターが近い距離」にある船、その中でも最も小さいID番号を持つ船の事になる。
@NEAREST_ANY_COUNTRY_SHIP_CHECK(CENTER_POS, CHECK_COUNTRY)
#DIM CENTER_POS
#DIM CHECK_COUNTRY

#DIM CHECK_SHIP_ID
#DIM CHECK_SECTOR_DISTANCE
#DIM CHECK_POS_DISTANCE

#DIM NEAREST_SHIP_ID
#DIM NEAREST_SECTOR_DISTANCE
#DIM NEAREST_POS_DISTANCE


;初期化
NEAREST_SHIP_ID = -1
NEAREST_SECTOR_DISTANCE = -1
NEAREST_POS_DISTANCE = -1

FOR CHECK_SHIP_ID, 0, MAX_SHIP
	IF SHIP_COUNTRY:CHECK_SHIP_ID == CHECK_COUNTRY
		CALL POS_DISTANCE_CHECK(CENTER_POS, SHIP_POSITION:CHECK_SHIP_ID)
		CHECK_SECTOR_DISTANCE = RESULT:0
		CHECK_POS_DISTANCE = RESULT:1

		;　距離が0よりも小さい=初期化されたままの場合か、チェック中の船の距離が今までで一番短い距離の船であるか、距離は同じでもセクターがより近い船であるなら、最も短い距離の船を更新する。
		IF NEAREST_POS_DISTANCE < 0 || NEAREST_POS_DISTANCE > CHECK_POS_DISTANCE || (NEAREST_POS_DISTANCE == CHECK_POS_DISTANCE && NEAREST_SECTOR_DISTANCE > CHECK_SECTOR_DISTANCE )
			NEAREST_SHIP_ID = CHECK_SHIP_ID
			NEAREST_SECTOR_DISTANCE = CHECK_SECTOR_DISTANCE
			NEAREST_POS_DISTANCE = CHECK_POS_DISTANCE
		ENDIF
	ENDIF
NEXT


RETURN NEAREST_SHIP_ID
;---------------------------------
; 指定された2つの座標のセクター同士の距離・距離(単位・マス目)を返す
; RESULT:0 MOVERとTARGETの居るセクターの距離
; RESULT:1 (TARGETが静止しているものとして)MOVERが自動航行でTARGETまで移動する場合の距離
; (セクター間移動の場合は1セクター=13マス(セクターに進入した時点で1マス内側に出るので)で移動として計算(セクターが長方形とかになるとこの方法は使えなくなる)+始点・終点の移動は自動移動でのセクターからの脱出・セクターへの進入の動きを考えたもので計算)
;---------------------------------
; 「移動」命令などで(自動航行で)対象の船を追いかけるのを前提に追いかける(MOVER)側と追いかけられる(TARGET)側とする
; これが返す距離はあくまで自動航行の動きで移動した場合の距離なのでMOVERとTARGETがひっくり返ると別の答えが出る。
@POS_DISTANCE_CHECK(MOVER_POS, TARGET_POS)
#DIM MOVER_POS
#DIM MOVER_SECTOR_ID
#DIM MOVER_SECTOR_POS_Y
#DIM MOVER_SECTOR_POS_X
#DIM MOVER_X_POS
#DIM MOVER_Y_POS

#DIM TARGET_POS
#DIM TARGET_SECTOR_ID
#DIM TARGET_SECTOR_POS_Y
#DIM TARGET_SECTOR_POS_X
#DIM TARGET_X_POS
#DIM TARGET_Y_POS

#DIM SECTOR_Y_DISTANCE
#DIM SECTOR_X_DISTANCE

#DIM X_POS_DISTANCE
#DIM Y_POS_DISTANCE

#DIM POS_DISTANCE
#DIM SECTOR_DISTANCE

#DIM CONST ONESECTOR_MOVING_DISTANCE = 13

CALL ID2POS(MOVER_POS)
MOVER_SECTOR_ID = RESULT:0
MOVER_X_POS = RESULT:1
MOVER_Y_POS = RESULT:2

; セクターは横方向が下の桁・縦方向が上の桁っぽい
; 移動処理側ではセクターの縦方向をY軸と呼んでいる
MOVER_SECTOR_POS_Y = MOVER_SECTOR_ID / 10
MOVER_SECTOR_POS_X = MOVER_SECTOR_ID - (MOVER_SECTOR_POS_Y * 10)

CALL ID2POS(TARGET_POS)
TARGET_SECTOR_ID = RESULT:0
TARGET_X_POS = RESULT:1
TARGET_Y_POS = RESULT:2

TARGET_SECTOR_POS_Y = TARGET_SECTOR_ID / 10
TARGET_SECTOR_POS_X = TARGET_SECTOR_ID - TARGET_SECTOR_POS_Y * 10

SECTOR_Y_DISTANCE = MOVER_SECTOR_POS_Y - TARGET_SECTOR_POS_Y
SECTOR_X_DISTANCE = MOVER_SECTOR_POS_X - TARGET_SECTOR_POS_X

IF SECTOR_Y_DISTANCE != 0
	; 上下に差があるなら
	X_POS_DISTANCE = ABS(MOVER_X_POS - MAP_WIDTH / 2)
	IF SECTOR_Y_DISTANCE > 0
		; 少なくとも上
		Y_POS_DISTANCE = MOVER_Y_POS
		IF SECTOR_X_DISTANCE > 0
			; 左上
			X_POS_DISTANCE += ABS((MAP_WIDTH - 2) - TARGET_X_POS)
			Y_POS_DISTANCE += ABS(TARGET_Y_POS - MAP_HEIGHT / 2)
		ELSEIF SECTOR_X_DISTANCE < 0
			; 右上
			X_POS_DISTANCE += ABS(1 - TARGET_X_POS)
			Y_POS_DISTANCE += ABS(TARGET_Y_POS - MAP_HEIGHT / 2)
		ELSE
			; 純粋に上
			X_POS_DISTANCE += ABS(TARGET_X_POS - MAP_WIDTH / 2)
			Y_POS_DISTANCE += ABS(MAP_HEIGHT - TARGET_Y_POS - 2)
		ENDIF
	ELSE
		; 少なくとも下
		Y_POS_DISTANCE = MAP_HEIGHT - (MOVER_Y_POS + 1)
		IF SECTOR_X_DISTANCE > 0
			; 左下
			X_POS_DISTANCE += ABS(MAP_WIDTH - TARGET_X_POS - 2)
			Y_POS_DISTANCE += ABS(TARGET_Y_POS - MAP_HEIGHT / 2)
		ELSEIF SECTOR_X_DISTANCE < 0
			; 右下
			X_POS_DISTANCE += ABS(1 - TARGET_X_POS)
			Y_POS_DISTANCE += ABS(TARGET_Y_POS - MAP_HEIGHT / 2)
		ELSE
			; 純粋に下
			X_POS_DISTANCE += ABS(TARGET_X_POS - MAP_WIDTH / 2)
			Y_POS_DISTANCE += ABS(1 - TARGET_Y_POS)
		ENDIF
	ENDIF
ELSEIF SECTOR_X_DISTANCE != 0
	; 上下には差がなくて・左右に差があるなら
	Y_POS_DISTANCE = ABS(MOVER_Y_POS - MAP_HEIGHT / 2)
	Y_POS_DISTANCE += ABS(TARGET_Y_POS - MAP_HEIGHT / 2)
	IF SECTOR_X_DISTANCE > 0
		; 左
		X_POS_DISTANCE = MOVER_X_POS
		X_POS_DISTANCE += ABS(MAP_WIDTH - TARGET_X_POS - 2)
	ELSE
		; 右
		X_POS_DISTANCE = MAP_WIDTH - (MOVER_X_POS + 1)
		X_POS_DISTANCE += ABS(1 - TARGET_X_POS)
	ENDIF
ELSE
	; 同一セクターなら
	X_POS_DISTANCE = ABS(MOVER_X_POS - TARGET_X_POS)
	Y_POS_DISTANCE = ABS(MOVER_Y_POS - TARGET_Y_POS)
ENDIF

SECTOR_DISTANCE = ABS(SECTOR_Y_DISTANCE) + ABS(SECTOR_X_DISTANCE)
IF SECTOR_DISTANCE == 0
	POS_DISTANCE = X_POS_DISTANCE + Y_POS_DISTANCE
ELSE
	POS_DISTANCE = (SECTOR_DISTANCE - 1) * ONESECTOR_MOVING_DISTANCE + X_POS_DISTANCE + Y_POS_DISTANCE
ENDIF

RESULT:0 = SECTOR_DISTANCE
RESULT:1 = POS_DISTANCE

RETURN RESULT