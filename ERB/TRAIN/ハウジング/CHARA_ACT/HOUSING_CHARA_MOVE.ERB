;-------------------------------------------------
; キャラクターの移動処理
;-------------------------------------------------
;キャラ移動処理の本体
@HO_CHARAACT_MOVE_MAIN(IDX)
#DIM IDX
#DIM DYNAMIC CHARA_ID
#DIM DYNAMIC キャラ現在地
#DIM DYNAMIC 移動先ROOM_IDX
;IDを取得
CALL HO_GET_CHARADATA(IDX, "CHARA_ID")
CHARA_ID = RESULT
;キャラが現在いる部屋を取得
CALL HO_GET_CHARADATA(IDX, "ROOM_IDX")
キャラ現在地 = RESULT
CALL HO_CHARAACT_MOVE(IDX)
;移動していない場合は処理を終了
SIF RESULT == -1
    RETURN
移動先ROOM_IDX = RESULT
CALL HO_GET_ROOM_NAME(移動先ROOM_IDX)
IF 移動先ROOM_IDX != HO_MASTER現在地
    PRINTFORML %ANAME(CHARA_ID)%は%RESULTS%に移動したようだ
ELSE
    PRINTFORML %ANAME(CHARA_ID)%が%RESULTS%に入ってきた
ENDIF

;キャラ移動処理に伴うデータ操作
@HO_CHARAACT_MOVE(IDX)
#DIM IDX
#DIMS DYNAMIC _LIST_MOVELIST
#DIM  DYNAMIC 移動先ROOM_IDX

;移動リストが存在するなら移動処理を実効する
CALL HO_GET_CHARADATA(IDX, "MOVELIST")
SIF RESULT == -1
    RETURN -1
_LIST_MOVELIST = %RESULTS%
SIF LIST_COUNT(_LIST_MOVELIST) == 0
    RETURN -1
移動先ROOM_IDX = TOINT(LIST_GET(_LIST_MOVELIST, 0))
_LIST_MOVELIST = %LIST_REMOVEAT(_LIST_MOVELIST, 0)%
CALL HO_SET_CHARADATA(IDX, "MOVELIST", _LIST_MOVELIST)
CALL HO_SET_CHARADATA(IDX, "ROOM_IDX", TOSTR(移動先ROOM_IDX))
;移動処理終了後も移動リストが残っている場合はキャラの状態を"移動中"に
IF LIST_COUNT(_LIST_MOVELIST) > 0
    CALL HO_SET_CHARADATA(IDX, "ACTION", "移動中")
ELSE 
    CALL HO_SET_CHARADATA(IDX, "ACTION", "待機")
ENDIF
RETURN 移動先ROOM_IDX

;-------------------------------------------------
; プレイヤーの移動処理
;-------------------------------------------------
@HO_MOVE_MASTER(ROOM_IDX, STOP_TIME_PROGRESS = 0)
#DIM ROOM_IDX
#DIM STOP_TIME_PROGRESS
#DIMS DYNAMIC ACTIONTYPE
#DIM DYNAMIC CHARA_ID
#DIM DYNAMIC CHARA_IDX

;コマンド継続状況を解除
CALL INIT_EQUIP

;MASTERのモジュール使用状態を解除する
CALL HO_GET_MASTER_DATA("MODULE_USAGE")
IF RESULT != -1
    CALL HO_MASTER_STOP_USE_MODULE(HO_MASTER現在地, RESULT)
ENDIF

;MASTERを移動させる
CALL HO_GET_ROUTE(HO_MASTER現在地, ROOM_IDX)
IF RESULT == -1
    CALL COLOR_PRINTW("移動先に到達可能な経路が存在しません", カラー_注意)
    CLEARLINE 1
    RETURN -1
ENDIF
HO_MASTER現在地 = ROOM_IDX
;通常の移動でない場合、時間経過処理を中断
SIF STOP_TIME_PROGRESS == 0
    CALL HOUSING_TIME_PROGRESS(RESULT, 1)

;同行中のキャラクターはマスターと一緒に移動する
WHILE _DIC_HO_CHARALIST:CHARA_IDX != "-1"
    CALL HO_GET_CHARADATA(CHARA_IDX, "ACTION")
    ACTIONTYPE = %RESULTS%
    CALL HO_GET_CHARADATA(CHARA_IDX, "CHARA_ID")
    CHARA_ID = RESULT
    IF ACTIONTYPE == "同行中"
        CALL HO_SET_CHARAPLACE(CHARA_ID, HO_MASTER現在地)
    ENDIF
    CHARA_IDX ++
WEND



;-------------------------------------------------
;;現在地から目的地までの最短経路を探索し経路をLIST形式で返却する
; 幅優先探索
; 到達可能な場合は最短経路をリスト形式で返却, 距離を数値で返却
; 目的地が現在地と同じ場合は空文字を返却
; 到達不可の場合は"-1"を返却
;-------------------------------------------------
@HO_GET_ROUTE(ROOM_IDX_FROM, ROOM_IDX_TO, MAP_ID = -1)
#DIM ROOM_IDX_FROM
#DIM ROOM_IDX_TO
#DIM MAP_ID
#DIM CONST MAX_VALUE = 999999 ;距離として取り得ない大きい値であればよい
#DIMS DYNAMIC _LIST_QUEUE
#DIMS DYNAMIC _LIST_PATH
#DIMS DYNAMIC _LIST_ROUTE
#DIMS DYNAMIC _LIST_TEMP
#DIM DYNAMIC QUEUE_IDX
#DIM DYNAMIC NODE_SCORE, HO_MAX_ROOMNUM
#DIM DYNAMIC NODE_FROM, HO_MAX_ROOMNUM
#DIM DYNAMIC DIST
#DIM DYNAMIC MIN_DIST
#DIM DYNAMIC CURRENT_NODE

SIF MAP_ID == -1
    MAP_ID = HO_有効マップID

;現在地と目的地が同じなら移動リストなし、距離0
IF ROOM_IDX_FROM == ROOM_IDX_TO
    RESULTS '= ""
    RETURN 0
ENDIF

DIST = 1
MIN_DIST = MAX_VALUE
CURRENT_NODE = ROOM_IDX_FROM

WHILE QUEUE_IDX < HO_MAX_ROOMNUM
    CALL HO_GET_PATH(CURRENT_NODE)
    _LIST_PATH = %RESULTS%
    FOR LOCAL, 0, LIST_COUNT(_LIST_PATH)
        SIF LIST_INDEXOF(_LIST_QUEUE, LIST_GET(_LIST_PATH, LOCAL)) != -1
            CONTINUE
        _LIST_QUEUE = %LIST_ADD(_LIST_QUEUE, LIST_GET(_LIST_PATH, LOCAL))%
        NODE_SCORE:TOINT(LIST_GET(_LIST_PATH, LOCAL)) = NODE_SCORE:CURRENT_NODE + 1
        NODE_FROM:TOINT(LIST_GET(_LIST_PATH, LOCAL)) = CURRENT_NODE
    NEXT
    CURRENT_NODE = TOINT(LIST_GET(_LIST_QUEUE, QUEUE_IDX))
    IF CURRENT_NODE == ROOM_IDX_TO && NODE_SCORE:CURRENT_NODE < MIN_DIST
        MIN_DIST = NODE_SCORE:CURRENT_NODE
    ENDIF
    QUEUE_IDX ++
WEND
SIF MIN_DIST == MAX_VALUE
    RETURN -1

;到達可能であれば経路を復元
CURRENT_NODE = ROOM_IDX_TO
_LIST_TEMP = %LIST_ADD(_LIST_TEMP, TOSTR(ROOM_IDX_TO))%
FOR LOCAL, 0, MIN_DIST - 1
    _LIST_TEMP = %LIST_ADD(_LIST_TEMP, TOSTR(NODE_FROM:CURRENT_NODE))%
    CURRENT_NODE = NODE_FROM:CURRENT_NODE
NEXT
FOR LOCAL, MIN_DIST - 1, -1, -1
    _LIST_ROUTE = %LIST_ADD(_LIST_ROUTE, LIST_GET(_LIST_TEMP, LOCAL))%
NEXT
RESULTS = %_LIST_ROUTE%
RETURN MIN_DIST